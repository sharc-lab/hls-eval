Kernel Description:
The `needwun` kernel implements the Needleman-Wunsch algorithm for global pairwise sequence alignment. This algorithm is a dynamic programming approach that finds the optimal alignment between two input sequences, `SEQA` and `SEQB`, by maximizing the similarity score between the two sequences. The design consists of two main stages: matrix filling and traceback. In the matrix filling stage, the design computes the similarity scores between the input sequences and stores them in a 2D matrix `M`. The similarity score is calculated based on the match, mismatch, and gap scores, which are defined as `MATCH_SCORE`, `MISMATCH_SCORE`, and `GAP_SCORE` respectively. The matrix `M` is filled in a row-major order, where each element `M[i][j]` represents the maximum similarity score between the subsequences `SEQA[0..i-1]` and `SEQB[0..j-1]`. The traceback stage traces back the optimal alignment path from the filled matrix and generates the aligned sequences `alignedA` and `alignedB`. The aligned sequences are generated by following the pointers stored in the `ptr` matrix, which indicates the direction of the optimal alignment path. The kernel also pads the aligned sequences with underscores to ensure a fixed length of `ALEN+BLEN` characters.

The algorithm can be represented by the following recurrence relation:
\[ M[i][j] = \max \begin{cases} M[i-1][j-1] + score(SEQA[i-1], SEQB[j-1]) \\ M[i-1][j] + GAP_SCORE \\ M[i][j-1] + GAP_SCORE \end{cases} \]
where `score(SEQA[i-1], SEQB[j-1])` is the match or mismatch score between the characters `SEQA[i-1]` and `SEQB[j-1]`.

The kernel uses the following variables:
- `SEQA` and `SEQB`: the input sequences
- `M`: the 2D matrix to store the similarity scores
- `ptr`: the 2D matrix to store the traceback pointers
- `alignedA` and `alignedB`: the aligned sequences
- `MATCH_SCORE`, `MISMATCH_SCORE`, and `GAP_SCORE`: the scores for match, mismatch, and gap respectively

The kernel has a time complexity of O(ALEN*BLEN) and a space complexity of O(ALEN*BLEN), where ALEN and BLEN are the lengths of the input sequences.

---

Top-Level Function: `needwun`

Complete Function Signature of the Top-Level Function:
`void needwun(char SEQA[ALEN], char SEQB[BLEN], char alignedA[ALEN + BLEN], char alignedB[ALEN + BLEN], int M[(ALEN + 1) * (BLEN + 1)], char ptr[(ALEN + 1) * (BLEN + 1)])`

Inputs:
- `SEQA`: a 1D array of characters representing the first input sequence, with a length of `ALEN` (128) characters.
- `SEQB`: a 1D array of characters representing the second input sequence, with a length of `BLEN` (128) characters.
- `alignedA`: a 1D array of characters to store the aligned sequence A, with a length of `ALEN+BLEN` characters.
- `alignedB`: a 1D array of characters to store the aligned sequence B, with a length of `ALEN+BLEN` characters.
- `M`: a 2D array of integers to store the similarity scores, with a size of `(ALEN+1) x (BLEN+1)`.
- `ptr`: a 2D array of characters to store the traceback pointers, with a size of `(ALEN+1) x (BLEN+1)`.

Outputs:
- `alignedA`: the aligned sequence A, stored in the input array.
- `alignedB`: the aligned sequence B, stored in the input array.

Important Data Structures and Data Types:
- `M`: a 2D array of integers to store the similarity scores, with a size of `(ALEN+1) x (BLEN+1)`. Each element in the array represents the maximum similarity score between the subsequences of `SEQA` and `SEQB`.
- `ptr`: a 2D array of characters to store the traceback pointers, with a size of `(ALEN+1) x (BLEN+1)`. Each element in the array represents the direction of the optimal alignment path.

Sub-Components:
- `init_row` and `init_col`: initialization loops to set the boundary values of the matrix `M`.
- `fill_out` and `fill_in`: nested loops to fill the matrix `M` with similarity scores.
- `trace`: a loop to trace back the optimal alignment path from the filled matrix and generate the aligned sequences.
- `pad_a` and `pad_b`: loops to pad the aligned sequences with underscores to ensure a fixed length of `ALEN+BLEN` characters.